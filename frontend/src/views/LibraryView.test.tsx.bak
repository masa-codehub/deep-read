import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import LibraryView from './LibraryView';
import { uploadPDFFile, getLibraryDocuments, getDocumentStatus, Document } from '../services/api';

// テスト全体のタイムアウト設定を延長
jest.setTimeout(60000);

// ポーリング間隔を短縮するためのモック
(global as any).process.env.NODE_ENV = 'test';

// APIをモック化
jest.mock('../services/api');
const mockUploadPDFFile = uploadPDFFile as jest.MockedFunction<typeof uploadPDFFile>;
const mockGetLibraryDocuments = getLibraryDocuments as jest.MockedFunction<typeof getLibraryDocuments>;
const mockGetDocumentStatus = getDocumentStatus as jest.MockedFunction<typeof getDocumentStatus>;

// モックファイルオブジェクトを作成するヘルパー関数
const createMockFile = (name: string, size: number, type: string) => {
  const file = new File([''], name, { type });
  Object.defineProperty(file, 'size', { value: size });
  return file;
};

// Document型と一致するモックデータを作成
const mockDocuments: Document[] = [
  {
    id: '1',
    title: 'Document 1',
    fileName: 'document_1.pdf',
    updatedAt: new Date().toISOString(),
    status: 'Ready',
    thumbnailUrl: 'https://via.placeholder.com/150',
  },
  {
    id: '2',
    title: 'Document 2',
    fileName: 'document_2.pdf',
    updatedAt: new Date().toISOString(),
    status: 'Processing',
    progress: 50,
    thumbnailUrl: 'https://via.placeholder.com/150',
  },
];

describe('LibraryView', () => {
  beforeEach(() => {
    // 各テストの前にモックをリセット
    jest.clearAllMocks();
    
    // デフォルトのモック実装を設定
    mockGetLibraryDocuments.mockResolvedValue({
      documents: mockDocuments,
      totalCount: mockDocuments.length,
      currentPage: 1,
      pageSize: 10,
      totalPages: 1
    });
    
    // getDocumentStatusのデフォルト実装
    mockGetDocumentStatus.mockImplementation(async (id) => {
      // IDに対応するドキュメントを模擬レスポンスから検索
      const mockDoc = mockDocuments.find(doc => doc.id === id);
      if (mockDoc) {
        return {
          id: mockDoc.id,
          status: mockDoc.status,
          progress: mockDoc.progress
        };
      }
      return null;
    });
  });

  // 基本的なUIが正しくレンダリングされることをテスト
  test('renders library view with upload button', async () => {
    render(<LibraryView />);
    expect(await screen.findByText('ライブラリ')).toBeInTheDocument();
    expect(screen.getByTestId('pdf-upload-button')).toBeInTheDocument();
  });

  // ドキュメントが正しく表示されることをテスト
  test('renders documents in the library', async () => {
    render(<LibraryView />);
    
    // ドキュメントタイトルが表示されるのを待つ
    await waitFor(() => {
      expect(screen.getByTestId('document-title-1')).toBeInTheDocument();
      expect(screen.getByTestId('document-title-2')).toBeInTheDocument();
    });
    
    // 1つ目のドキュメントが「準備完了」と表示されること
    expect(screen.getByTestId('status-1')).toHaveTextContent('準備完了');
    
    // 2つ目のドキュメントが「処理中...」と表示されること
    const processingEl = screen.getByTestId('progress-text-2');
    expect(processingEl).toBeInTheDocument();
    expect(processingEl.textContent).toContain('50%');
  });

  // ファイルアップロード処理のテスト
  test('handles file upload flow correctly', async () => {
    // プログレスコールバックとPromise解決を制御するための変数
    let progressCallback: ((progress: number) => void) | undefined;
    let resolveUploadPromise: ((value: { success: boolean; message: string; documentId: string }) => void) | undefined;

    // アップロードのPromise解決をテスト側から制御できるように実装
    mockUploadPDFFile.mockImplementation(async (file, progressCb) => {
      progressCallback = progressCb; // コールバックを保存
      return new Promise<{ success: boolean; message: string; documentId?: string }>(resolve => {
        resolveUploadPromise = resolve; // Promiseの解決を外部から制御できるようにする
      });
    });

    // より安定したモックレスポンスを設定
    mockGetLibraryDocuments.mockResolvedValue({
      documents: mockDocuments,
      totalCount: mockDocuments.length,
      currentPage: 1,
      pageSize: 10,
      totalPages: 1
    });

    // コンポーネントをレンダリング
    render(<LibraryView />);
    
    // 初期表示の確認
    await screen.findByText('ライブラリ');
    
    // より明確なファイル選択処理
    const testFile = createMockFile('test.pdf', 1024 * 1024, 'application/pdf');
    const fileInput = screen.getByTestId('file-input');
    
    // act内でファイル選択イベントを発火
    await act(async () => {
      fireEvent.change(fileInput, { target: { files: [testFile] } });
    });
    
    // モーダルが開いたことをdata-testidで確認
    await waitFor(() => {
      const modal = screen.getByTestId('upload-modal');
      expect(modal).toBeInTheDocument();
    }, { timeout: 5000 });
    
    // ファイル名が表示されたことを確認
    await waitFor(() => {
      expect(screen.getByTestId('upload-filename')).toHaveTextContent('test.pdf');
    }, { timeout: 3000 });
    
    // アップロード開始ボタンをクリック
    const startButton = screen.getByTestId('upload-start-button');
    await act(async () => {
      fireEvent.click(startButton);
    });
    
    // まずモーダルのタイトルが「アップロード中...」になることを確認
    await waitFor(() => {
      expect(screen.getByTestId('upload-modal-title')).toHaveTextContent('アップロード中...');
    }, { timeout: 5000 });
    
    // 最終的なプログレスのみを確認（100%）- 途中経過は省略
    await waitFor(() => {
      expect(screen.getByTestId('upload-progress-text')).toHaveTextContent('100%');
    }, { timeout: 10000 });
    
    // 完了メッセージが表示されることを確認
    await waitFor(() => {
      expect(screen.getByTestId('upload-message')).toHaveTextContent('モック: アップロード成功！');
      expect(screen.getByTestId('upload-modal-title')).toHaveTextContent('アップロード完了');
    }, { timeout: 5000 });
  }, 50000); // タイムアウトを十分に長く設定

  // エラーハンドリングのテスト
  test('handles upload error correctly', async () => {
    // エラー応答をモック
    mockUploadPDFFile.mockImplementation(async (_, progressCb) => {
      // まず進捗を表示してからエラーにする
      if (progressCb) {
        // 少し進行してからエラー
        await act(async () => { progressCb(10); });
        await new Promise(r => setTimeout(r, 100));
      }
      throw new Error('モック: ファイルサイズが上限を超えています。');
    });
    
    // 明示的にモックをリセットして状態を確実に
    mockGetLibraryDocuments.mockClear();
    mockGetLibraryDocuments.mockResolvedValue({
      documents: mockDocuments,
      totalCount: mockDocuments.length,
      currentPage: 1,
      pageSize: 10,
      totalPages: 1
    });
    
    render(<LibraryView />);
    
    // 初期表示の確認 (レンダリング完了を待つ)
    await screen.findByText('ライブラリ');
    
    // ドキュメントのロードを待つ (より具体的な条件で)
    await waitFor(() => {
      expect(mockGetLibraryDocuments).toHaveBeenCalled();
      expect(screen.getByTestId('document-title-1')).toBeInTheDocument();
    }, { timeout: 5000 });
    
    // より明確なファイルサイズでテストファイルを作成
    const file = createMockFile('large.pdf', 200 * 1024 * 1024, 'application/pdf');
    const fileInput = screen.getByTestId('file-input');
    
    // ファイル選択イベントを発火
    await act(async () => {
      fireEvent.change(fileInput, { target: { files: [file] } });
    });
    
    // モーダルが表示されるのを確実に待つ
    await waitFor(() => {
      const modal = screen.getByTestId('upload-modal');
      expect(modal).toBeInTheDocument();
    }, { timeout: 5000 });
    
    // ファイル名が表示されることを確認
    expect(screen.getByTestId('upload-filename')).toHaveTextContent('large.pdf');
    
    // アップロード開始ボタンをクリック
    const uploadButton = screen.getByTestId('upload-start-button');
    await act(async () => {
      fireEvent.click(uploadButton);
    });
    
    // エラーメッセージが表示されるのを待つ
    await waitFor(() => {
      expect(mockUploadPDFFile).toHaveBeenCalledWith(file, expect.any(Function));
      // モーダルのタイトルとエラーメッセージの両方を一度に確認
      expect(screen.getByTestId('upload-modal-title')).toHaveTextContent('アップロードエラー');
      expect(screen.getByTestId('upload-error-message')).toHaveTextContent(/ファイルサイズが上限を超えています/i);
    }, { timeout: 10000 });
    
    // エラー後のモーダルの閉じるボタンが機能することを確認
    const closeButton = screen.getByTestId('footer-close-button');
    fireEvent.click(closeButton);
    
    await waitFor(() => {
      expect(screen.queryByTestId('upload-modal')).not.toBeInTheDocument();
    }, { timeout: 5000 });
  }, 50000); // タイムアウト時間を十分長く設定

  // ステータス更新の基本テスト
  test('shows document status correctly', async () => {
    // 通常、処理中、エラーの3つのステータスのドキュメントを用意
    const statusDocs: Document[] = [
      { ...mockDocuments[0], status: 'Ready' },
      { ...mockDocuments[1], status: 'Processing', progress: 75 },
      { 
        id: '3', 
        title: 'Error Document', 
        fileName: 'error.pdf',
        updatedAt: new Date().toISOString(),
        status: 'Error',
        thumbnailUrl: 'https://via.placeholder.com/150'
      }
    ];
    
    mockGetLibraryDocuments.mockResolvedValueOnce({
      documents: statusDocs,
      totalCount: statusDocs.length,
      currentPage: 1,
      pageSize: 10,
      totalPages: 1
    });
    
    render(<LibraryView />);
    
    // 各ステータスが正しく表示されていることを確認
    await waitFor(() => {
      expect(screen.getByTestId('document-title-1')).toBeInTheDocument();
      expect(screen.getByTestId('document-title-3')).toBeInTheDocument();
    });
    
    // 各ステータスラベルが正しく表示されていることを確認
    expect(screen.getByTestId('status-1')).toHaveTextContent('準備完了');
    expect(screen.getByTestId('progress-text-2')).toHaveTextContent(/処理中.*75%/);
    expect(screen.getByTestId('status-3')).toHaveTextContent('エラー');
  });

  // ポーリングロジックのテスト
  test('polls for document status updates and updates the UI', async () => {
    jest.useFakeTimers(); // フェイクタイマーを使用
    
    // デフォルトのmockGetDocumentStatusの動作を上書きして、
    // initialProcessingDocのIDに対しては常に正しい状態を返すように設定
    mockGetDocumentStatus.mockImplementation(async (id: string) => {
      if (id === 'doc-processing') {
        return { id, status: 'Processing' as const, progress: 50 }; // 初期表示用
      }
      // nullは返せないため、デフォルトでReadyを返す
      return { id, status: 'Ready' as const, progress: 100 };
    });

    // 「処理中」状態のドキュメントで開始
    const initialProcessingDoc: Document = {
      id: 'doc-processing',
      title: 'Processing Document',
      fileName: 'processing.pdf',
      updatedAt: new Date().toISOString(),
      status: 'Processing', // リテラル型として処理中状態
      progress: 50, // 50%の進行状態
      thumbnailUrl: 'https://via.placeholder.com/150'
    };
    
    mockGetLibraryDocuments.mockResolvedValue({
      documents: [initialProcessingDoc],
      totalCount: 1,
      currentPage: 1,
      pageSize: 10,
      totalPages: 1
    });

    // useEffect内の最初のupdateDocumentStatusの後の
    // 次回以降のポーリング用にモックをセット
    mockGetDocumentStatus
      .mockResolvedValueOnce({
        id: 'doc-processing',
        status: 'Processing' as const,
        progress: 75 // 進行状況が更新される
      })
      .mockResolvedValueOnce({
        id: 'doc-processing',
        status: 'Ready' as const, // 最終的に完了状態になる
        progress: 100
      });

    // コンポーネントをレンダリング
    render(<LibraryView />);

    // 初期状態: まずドキュメントが表示されていることを確認
    await waitFor(() => {
      const docTitle = screen.getByTestId('document-title-doc-processing');
      expect(docTitle).toBeInTheDocument();
      expect(docTitle).toHaveTextContent('Processing Document');
    }, { timeout: 5000 });

    // 進捗インジケータが表示されていることを確認
    await waitFor(() => {
      const progressIndicator = screen.getByTestId('progress-indicator-doc-processing');
      expect(progressIndicator).toBeInTheDocument();
      
      // 初期進捗が50%であることを確認
      const progressText = screen.getByTestId('progress-text-doc-processing');
      expect(progressText.textContent).toContain('50%');
    }, { timeout: 5000 });
    
    // 1回目のポーリング: タイマーを進める
    await act(async () => {
      jest.advanceTimersByTime(1000); // テスト環境では1秒間隔
      await Promise.resolve(); // 非同期処理の完了を待つ
    });
    
    // ポーリングによる更新: 75%に更新されることを確認
    await waitFor(() => {
      const progressText = screen.getByTestId('progress-text-doc-processing');
      expect(progressText.textContent).toContain('75%');
    }, { timeout: 5000 });
    
    // 2回目のポーリング: タイマーを進める
    await act(async () => {
      jest.advanceTimersByTime(1000); // テスト環境では1秒間隔
      await Promise.resolve(); // 非同期処理の完了を待つ
    });
    
    // ポーリングによる更新: 完了状態になることを確認
    await waitFor(() => {
      const statusElement = screen.getByTestId('status-doc-processing');
      expect(statusElement).toHaveTextContent('準備完了');
    }, { timeout: 5000 });
    
    jest.useRealTimers(); // テスト終了後にタイマーを戻す
    
  }, 30000); // テスト全体のタイムアウトは適切に設定
});